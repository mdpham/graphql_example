"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const graphql_1 = require("graphql");
const chalk_1 = __importDefault(require("chalk"));
const git_1 = require("../../git");
const Command_1 = require("../../Command");
const utils_1 = require("../../utils");
const graphqlTypes_1 = require("apollo-language-server/lib/graphqlTypes");
const moment_1 = __importDefault(require("moment"));
const lodash_sortby_1 = __importDefault(require("lodash.sortby"));
const formatChange = (change) => {
    let color = (x) => x;
    if (change.severity === graphqlTypes_1.ChangeSeverity.FAILURE) {
        color = chalk_1.default.red;
    }
    if (change.severity === graphqlTypes_1.ChangeSeverity.WARNING) {
        color = chalk_1.default.yellow;
    }
    const changeDictionary = {
        [graphqlTypes_1.ChangeSeverity.FAILURE]: "FAIL",
        [graphqlTypes_1.ChangeSeverity.WARNING]: "WARN",
        [graphqlTypes_1.ChangeSeverity.NOTICE]: "PASS"
    };
    return {
        severity: color(changeDictionary[change.severity]),
        code: color(change.code),
        description: color(change.description)
    };
};
const reshapeGraphQLErrorToChange = (severity, message) => {
    return {
        severity,
        code: `FEDERATION_VALIDATION_${severity}`,
        description: message,
        __typename: "Change"
    };
};
function formatTimePeriod(hours) {
    if (hours <= 24) {
        return utils_1.pluralize(hours, "hour");
    }
    return utils_1.pluralize(Math.floor(hours / 24), "day");
}
exports.formatTimePeriod = formatTimePeriod;
function formatMarkdown({ checkSchemaResult, serviceName, tag }) {
    const { diffToPrevious } = checkSchemaResult;
    if (!diffToPrevious) {
        throw new Error("checkSchemaResult.diffToPrevious missing");
    }
    const { validationConfig } = diffToPrevious;
    if (!validationConfig) {
        throw new Error("checkSchemaResult.diffToPrevious.validationConfig missing");
    }
    const hours = Math.abs(moment_1.default()
        .add(validationConfig.from, "second")
        .diff(moment_1.default().add(validationConfig.to, "second"), "hours"));
    const breakingChanges = diffToPrevious.changes.filter(change => change.severity === "FAILURE");
    const affectedQueryCount = diffToPrevious.affectedQueries
        ? diffToPrevious.affectedQueries.length
        : 0;
    return `
### Apollo Service Check
ðŸ”„ Validated your local schema against schema tag \`${tag}\` on service \`${serviceName}\`.
ðŸ”¢ Compared **${utils_1.pluralize(diffToPrevious.changes.length, "schema change")}** against **${utils_1.pluralize(diffToPrevious.numberOfCheckedOperations, "operation")}** seen over the **last ${formatTimePeriod(hours)}**.
${breakingChanges.length > 0
        ? `âŒ Found **${utils_1.pluralize(diffToPrevious.changes.filter(change => change.severity === "FAILURE")
            .length, "breaking change")}** that would affect **${utils_1.pluralize(affectedQueryCount, "operation")}** across **${utils_1.pluralize(diffToPrevious.affectedClients && diffToPrevious.affectedClients.length, "client")}**`
        : `âœ… Found **no breaking changes**.`}

ðŸ”— [View your service check details](${checkSchemaResult.targetUrl}).
`;
}
exports.formatMarkdown = formatMarkdown;
function formatHumanReadable({ checkSchemaResult }) {
    const { targetUrl, diffToPrevious: { changes } } = checkSchemaResult;
    let result = "";
    if (changes.length === 0) {
        result = "\nNo changes present between schemas";
    }
    else {
        const sortedChanges = lodash_sortby_1.default(changes, [
            change => change.code,
            change => change.description
        ]);
        const breakingChanges = sortedChanges.filter(change => change.severity === graphqlTypes_1.ChangeSeverity.FAILURE);
        lodash_sortby_1.default(breakingChanges, change => change.severity);
        const nonBreakingChanges = sortedChanges.filter(change => change.severity !== graphqlTypes_1.ChangeSeverity.FAILURE);
        heroku_cli_util_1.table([
            ...breakingChanges.map(formatChange),
            nonBreakingChanges.length && breakingChanges.length ? {} : null,
            ...nonBreakingChanges.map(formatChange)
        ].filter(Boolean), {
            columns: [
                { key: "severity", label: "Change" },
                { key: "code", label: "Code" },
                { key: "description", label: "Description" }
            ],
            printHeader: () => { },
            printLine: line => {
                result += `\n${line}`;
            }
        });
    }
    if (targetUrl) {
        result += `\n\nView full details at: ${targetUrl}`;
    }
    return result;
}
exports.formatHumanReadable = formatHumanReadable;
class ServiceCheck extends Command_1.ProjectCommand {
    async run() {
        const taskOutput = {};
        const breakingChangesErrorMessage = "breaking changes found";
        const compositionErrorMessage = "composition errors found";
        let schema, schemaHash;
        try {
            await this.runTasks(({ config, flags, project }) => {
                const configName = config.name;
                const tag = flags.tag || config.tag || "current";
                if (!configName) {
                    throw new Error("No service found to link to Engine");
                }
                return [
                    {
                        title: `Validating local schema against tag ${chalk_1.default.blue(tag)} on service ${chalk_1.default.blue(configName)}`,
                        task: async (ctx, task) => {
                            task.output = "Resolving schema";
                            taskOutput.shouldOutputJson = flags.json;
                            if (flags.federated) {
                                const info = await project.resolveFederationInfo();
                                if (!info.sdl)
                                    throw new Error("No SDL found for federated service");
                                task.output = "Creating composed schema against the graph";
                                const { errors, compositionValidationDetails } = await project.engine.checkPartialSchema({
                                    id: configName,
                                    graphVariant: tag,
                                    implementingServiceName: flags.serviceName || info.name,
                                    partialSchema: {
                                        sdl: info.sdl
                                    }
                                });
                                taskOutput.federation = {
                                    errors
                                };
                                if (compositionValidationDetails) {
                                    schemaHash = compositionValidationDetails.schemaHash;
                                }
                                else {
                                    throw new Error(`Federated service could not be composed due to the following errors:
  ${errors && errors.map(err => (err && err.message) || "").join("\n")}
                  `);
                                }
                            }
                            else {
                                schema = await project.resolveSchema({ tag: config.tag });
                                await git_1.gitInfo(this.log);
                                const historicParameters = utils_1.validateHistoricParams({
                                    validationPeriod: flags.validationPeriod,
                                    queryCountThreshold: flags.queryCountThreshold,
                                    queryCountThresholdPercentage: flags.queryCountThresholdPercentage
                                });
                                task.output = "Validating schema";
                                const variables = Object.assign({ id: configName, schema: graphql_1.introspectionFromSchema(schema).__schema, tag: flags.tag, gitContext: await git_1.gitInfo(this.log), frontend: flags.frontend || config.engine.frontend }, (historicParameters && { historicParameters }));
                                const { schema: _ } = variables, restVariables = __rest(variables, ["schema"]);
                                this.debug("Variables sent to Engine:");
                                this.debug(restVariables);
                                this.debug("SDL of introspection sent to Engine:");
                                this.debug(graphql_1.printSchema(schema));
                                const newContext = {
                                    checkSchemaResult: await project.engine.checkSchema(variables),
                                    config,
                                    shouldOutputJson: !!flags.json,
                                    shouldOutputMarkdown: !!flags.markdown
                                };
                                Object.assign(ctx, newContext);
                                Object.assign(taskOutput, ctx);
                            }
                            task.title = task.title.replace("Validating", "Validated");
                        }
                    },
                    {
                        title: "Comparing schema changes",
                        task: async (ctx, task) => {
                            const schemaChanges = ctx.checkSchemaResult.diffToPrevious.changes;
                            const numberOfCheckedOperations = ctx.checkSchemaResult.diffToPrevious
                                .numberOfCheckedOperations || 0;
                            const validationConfig = ctx.checkSchemaResult.diffToPrevious.validationConfig;
                            const hours = validationConfig
                                ? Math.abs(moment_1.default()
                                    .add(validationConfig.from, "second")
                                    .diff(moment_1.default().add(validationConfig.to, "second"), "hours"))
                                : null;
                            task.title = `Compared ${utils_1.pluralize(chalk_1.default.blue(schemaChanges.length.toString()), "schema change")} against ${utils_1.pluralize(chalk_1.default.blue(numberOfCheckedOperations.toString()), "operation")}${hours
                                ? ` over the last ${chalk_1.default.blue(formatTimePeriod(hours))}`
                                : ""}`;
                        }
                    },
                    {
                        title: "Reporting result",
                        task: async (ctx, task) => {
                            const breakingSchemaChangeCount = ctx.checkSchemaResult.diffToPrevious.changes.filter(change => change.severity === graphqlTypes_1.ChangeSeverity.FAILURE).length;
                            const nonBreakingSchemaChangeCount = ctx.checkSchemaResult.diffToPrevious.changes.length -
                                breakingSchemaChangeCount;
                            task.title = `Found ${utils_1.pluralize(chalk_1.default.blue(breakingSchemaChangeCount.toString()), "breaking change")} and ${utils_1.pluralize(chalk_1.default.blue(nonBreakingSchemaChangeCount.toString()), "compatible change")}`;
                            if (breakingSchemaChangeCount) {
                                throw new Error(breakingChangesErrorMessage);
                            }
                        }
                    }
                ];
            }, context => ({
                renderer: context.flags.markdown || context.flags.json ? "silent" : "default"
            }));
        }
        catch (error) {
            if (error.message.includes("/upgrade")) {
                this.exit(1);
                return;
            }
            if (error.message !== breakingChangesErrorMessage &&
                error.message !== compositionErrorMessage) {
                throw error;
            }
        }
        const { checkSchemaResult, config, shouldOutputJson, shouldOutputMarkdown } = taskOutput;
        const { service } = config;
        if (!service) {
            throw new Error("Service mising from config. This should have been validated elsewhere");
        }
        if (taskOutput.federation) {
            const errors = taskOutput.federation.errors.map(error => reshapeGraphQLErrorToChange(graphqlTypes_1.ChangeSeverity.FAILURE, error ? error.message : ""));
            if (errors.length &&
                checkSchemaResult.diffToPrevious.severity !== graphqlTypes_1.ChangeSeverity.FAILURE) {
                checkSchemaResult.diffToPrevious.severity = graphqlTypes_1.ChangeSeverity.FAILURE;
            }
            checkSchemaResult.diffToPrevious.changes.push(...errors);
        }
        if (shouldOutputJson) {
            return this.log(JSON.stringify({
                targetUrl: checkSchemaResult.targetUrl,
                changes: checkSchemaResult.diffToPrevious.changes,
                validationConfig: checkSchemaResult.diffToPrevious.validationConfig
            }, null, 2));
        }
        else if (shouldOutputMarkdown) {
            const serviceName = config.service && config.service.name;
            if (!serviceName) {
                throw new Error("The service name should have been defined in the Apollo config and validated when the config was loaded. Please file an issue if you're seeing this error.");
            }
            return this.log(formatMarkdown({
                checkSchemaResult,
                serviceName,
                tag: config.tag
            }));
        }
        this.log(formatHumanReadable({ checkSchemaResult }));
        if (checkSchemaResult.diffToPrevious.changes.find(({ severity }) => severity === graphqlTypes_1.ChangeSeverity.FAILURE)) {
            this.exit(1);
        }
    }
}
ServiceCheck.aliases = ["schema:check"];
ServiceCheck.description = "Check a service against known operation workloads to find breaking changes";
ServiceCheck.flags = Object.assign({}, Command_1.ProjectCommand.flags, { tag: command_1.flags.string({
        char: "t",
        description: "The published tag to check this service against"
    }), validationPeriod: command_1.flags.string({
        description: "The size of the time window with which to validate the schema against. You may provide a number (in seconds), or an ISO8601 format duration for more granularity (see: https://en.wikipedia.org/wiki/ISO_8601#Durations)"
    }), queryCountThreshold: command_1.flags.integer({
        description: "Minimum number of requests within the requested time window for a query to be considered."
    }), queryCountThresholdPercentage: command_1.flags.integer({
        description: "Number of requests within the requested time window for a query to be considered, relative to total request count. Expected values are between 0 and 0.05 (minimum 5% of total request volume)"
    }), json: command_1.flags.boolean({
        description: "Output result in json, which can then be parsed by CLI tools such as jq.",
        exclusive: ["markdown"]
    }), localSchemaFile: command_1.flags.string({
        description: "Path to your local GraphQL schema file (introspection result or SDL)"
    }), markdown: command_1.flags.boolean({
        description: "Output result in markdown.",
        exclusive: ["json"]
    }), federated: command_1.flags.boolean({
        char: "f",
        default: false,
        description: "Indicates that the schema is a partial schema from a federated service"
    }), serviceName: command_1.flags.string({
        description: "Provides the name of the implementing service for a federated graph"
    }) });
exports.default = ServiceCheck;
//# sourceMappingURL=check.js.map